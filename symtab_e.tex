\label{symtab_e002}

\section{Data structure of symbol table and look up}
Scope of C language constructs hierarchy as described in
bibliography \cite{ISO} 6.1.2.1 Scopes of identifiers and
6.1.2.3 Name spaces of identifiers.

We mentioned in \ref{lex_yacc_e004} that lexical analizer must look up
symbol table. For getting an entry from string, we'll use
structure like below.

\label{symtab_e000}
\begin{verbatim}
struct usr;  // variable in program
struct tag;  // tag in program

struct scope {
  scope* m_parent;            // outer scope
  vector<scope*> m_children;  // inner scope
  map<string,usr*> m_usrs;    // get an entry from string
  map<string,tag*> m_tags;    // get an entry from string
  static scope* current;
  static scope root;
};
\end{verbatim}
\index{scope@scope}
\index{tag@tag}
\index{usr@usr}
\index{scope@scope}

It's necessary that compiler creates a new {\tt{scope}} or sets
{\tt{scope::current}} suitably while syntax analisysing.
And it's also neccessary that compiler sets {\tt{scope::current}} suitably
while generating 3 address code.
For this, we'll change grammer described in chapter \ref{lex_yacc_e000}
like below.

\begin{verbatim}
compound_statement
  : '{' enter_block block_item_list leave_block '}'
  | ...
  ;

enter_block
  : {
      ...
      vector<scope*>& children = scope::current->m_children;
      scope* tmp = new scope;
      tmp->m_parent = scope::current;
      children.push_back(tmp);
      scope::current = tmp;
    }
  ;

leave_block
  : { scope::current = scope::current->m_parent; ... ; }
  ;
\end{verbatim}

It's necessary that compiler remembers the order of parameters in
parameter scope.
\begin{verbatim}
struct param_scope : scope {
  vector<usr*> m_order;   // remember the order
};

direct_declarator
  : ...
  | direct_declarator '(' enter_param_scope
                          parameter_type_list
                          leave_param_scope ')'
  | ...
  ;

enter_param_scope
  : {
      vector<scope*>& children = scope::current->m_children;
      scope* param = new param_scope;
      param->m_parent = scope::current;
      children.push_back(param);
      scope::current = param;
    }
  ;

leave_param_scope
  : { scope::current = scope::current->m_parent; ... ; }
  ;
\end{verbatim}

Now, we can write  {\tt{lookup}} of \ref{lex_yacc_e004} like below.
\begin{verbatim}
int lookup(string name, scope* ptr = scope::current)
{
  if ( prev == STRUCT || prev == UNION || prev == ENUM ) {
    // previous token is one of struct, union or enum
    const map<string, tag*>& tags = ptr->m_tags;
    p = tags.find(name);
    if ( p != tags.end() )
      return TAG_NAME; // found
  }
  else {
    const map<string, usr*>& usrs = ptr->m_usrs;
    p = usrs.find(name);
    if ( p != usrs.end() ) {
      // found
      if ( p->second is typedefed )
        return TYPEDEF_NAME;
      return IDENTIFIER;
    }
  }

  if ( ptr->m_parent )
    return lookup(name,ptr->m_parent); // lookup outer scope

  return 0; // not found
}
\end{verbatim}

\begin{QandA}
Variables which share the same name are defined or declared
in the same scope multiply and validly. From that, for getting
entrys from string, below structure is correct. Is it true?
\begin{verbatim}
struct scope {
  ...
  map<string,vector<usr*> > m_usrs;  // correspond the plural
  ...
};
\end{verbatim}

Answer : That's right. For example, it's ncessary that
we change {\tt {scope}} like above for generating correct
code for below program piece.
\begin{verbatim}
void f(void)
{
  void g(int);
  extern int a;
  g(a);  // reference global `a'
  int a; // hide global `a'
  g(a);  // reference local `a'
}
\end{verbatim}
`{\tt{lookup}}' decides the last entry as a attribute of token.
\end{QandA}

\begin{QandA}
I think medium variables generated by compiler are in symbol table.

Answer : You're right. But comiler doesn't have to look up symbol table
for them, so we should distingish them. Also note that medium variables
can be in restricted scope. We define new {\tt{scope}} as a derived
class like below.
\begin{verbatim}
struct var;  // medium variable

struct block : scope {
  vector<var*> m_vars;
};

/* yacc program text */
enter_block
  : {
      ...
      vector<scope*>& children = scope::current->m_children;
      scope* tmp = new block;  /* change to `block' */
      tmp->m_parent = scope::current;
      children.push_back(tmp);
      scope::current = tmp;
    }
  ;
\end{verbatim}
\end{QandA}

\begin{QandA}
\label{symtab_e001}
What is {\tt{tag}}? How do we can defined {\tt{tag}}?

Answer : Structre, union, enumeration and incomplete of them
are named by programmer. Here, we call it {\tt{tag}}.
The name of {\tt{tag}} and that of variable are not conflict
event thought they have the same name.

\begin{verbatim}
struct tag {
  int m_kind;  // one of struct, union and enum
  string m_name;
  const type* m_type;
  file_t m_file;
  scope* m_scope;
};
\end{verbatim}
\end{QandA}
\index{tag@tag}

\begin{QandA}
Is it necessary that {\tt{tag}} is derived from {\tt{scope}}?

Answer : It's not ncessary in C compiler, but
necessary in C++ compiler. For example,
\begin{verbatim}
struct outer {
  struct inner {
    ...
  }
  ...
};

struct inner x; /* OK in C, error in C++. */
outer::inner y; // Specify name specifier in C++
\end{verbatim}
This example shows that structure or union creates
a new {\tt{scope}} in C++ and doesn't create in C.
There is also difference in generating 3 address code.
\begin{verbatim}
struct T {
  int x;
};

struct T t;
t.x;  // In C++, member reference operator . changes scope::current
      // to `T'.
      /* In C, because type of `t' is structure, reference the offset
         and type of member `x' */
\end{verbatim}
\end{QandA}
\index{tag@tag}

\begin{QandA}
In function definition and function declaration that is not definition,
I want to distingish whether creating a new parameter scope or not.
How can I do so?

Answer : Sorry but we cannot show the elegant method.
We think that we always create a new parameter scope in
function definition and declaration, and destroy it
if it isn't necessary any more.

It may be possible by changing grammer, and the {\tt{yacc}} action part
of {\tt{enter\_param\_scope}} or {\tt{leave\_param\_scope}} 
runs if necessary.
It may be also possible by some way, and you create a new parameter
scope when reducing {\tt{enter\_param\_scope}} if and only if it is
necessary.

The way of changing grammer may not work because of complexity of
grammer, we think. For example, consider below.

\begin{verbatim}
function_definition
  : function_definition_begin compound_statement
  ;

function_definition_begin
  : ...
  | declaration_specifiers declarator '(' enter_param_scope
                                          type_parameter_list
                                          leave_param_scope ')'
  | ...
  ;
\end{verbatim}
Other than {\tt{yacc}} will reports conflicts,
note that function declaration can be nested.
\begin{verbatim}
int (*f(int (*a)(double b)))(double c)
/* In above grammer, the parameter scope of `f' will be the scope
   where `c' declared. */
{
  return a;  /* This will be error in spite of OK. */
}
\end{verbatim}

On the other hand, create always a new {\tt{param\_scope}}
when {\tt{enter\_param\_scope}} is reducing. The order of
creation is like below.
\[
{\tt{int\,\,\,(\,*f(
\underbrace{{\tt{\,int\,\,\,(*a)(
\overbrace{\tt{\,double\,\,\,b\,}}^{2})\,}}}_{1})\,)
(\underbrace{\tt{\,double\,\,\,c}\,}_{3})}}
\]
Here,  {\tt{param\_scope}} 2 and 3 should be destroyed
when leaving the scope.
\end{QandA}

\section{Variable in program and medium variable}
\label{symtab_e003}
We mentioned about {\tt{tag}} in Question \ref{symtab_e001}, but
didn't about {\tt{usr}} or {\tt{var}} which denotes
variable in program text or medium variable, respectively.
Because {\tt{var}} is based class and {\tt{usr}} is derived class,
and there are many calsses derived from {\tt{var}}.
Here, we simply show the correspond structure.

At least, {\tt{var}} must has its type infomation.
A type infomation will be referenced by frontend while generating
3 address code. For example, if frontend detects the addition of
{\tt{i}} whose type is {\tt{int}} and {\tt{d}} whose type is
{\tt{double}}, frontend generates below 3 address code.
\begin{verbatim}
  t0 := (double)i  # convert to double
  t1 := t0 + d     # addition of double
\end{verbatim}
And then, when backend converts to target code,
backend allocates memory or register suitably for
{\tt{i}}, {\tt{d}}, {\tt{t0}} and {\tt{t1}}.

The operands of 3 address code are {\tt{var}}. And it is
possible that variables in program text are the operand of 3 address code.
So, we define {\tt{var}} and {\tt{usr}} like below.
\begin{verbatim}
struct var {
  const type* m_type;  // contain its type infomation
  ...
};

struct usr : var {  // derived from var
  string m_name;    // name in program text
  flag_t m_flag;    // storage class or other infomation
  file_t m_file;    // file position
  ...
};
\end{verbatim}
Please reference later chapter about {\tt{var}} more
precicely.

